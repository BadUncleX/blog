---
layout: post
title:  " golang并发续"
date:   2018-07-13 09:10:53 +0800
categories: golang 100days
typora-copy-images-to: ../assets/images/2018-07
typora-root-url: ../../blog_alexcode
---
<h2>Table of contents</h2>
* TOC
{:toc}
golang的并发大致 告一段落, 有几个场景的例子. 



## 只有一个账户的并发安全银行账户



```go
package bank

var deposits = make(chan int)  // 发送存款, 每一笔
var balances = make(chan int)  //接受余额, 直接最终结果
var withdraws = make(chan int) //发送取款, 每一笔

//存款
func Deposit(amount int) {
	deposits <- amount
}

//取款
func Withdraw(amount int) {
	withdraws <- amount
}

//余额
func Balance() int {
	return <-balances
}

func teller() {
	var balance int
	for {
		select {
		//存款, 累加
		case amout := <-deposits:
			balance += amout

		//取款, 累减
		case amount := <-withdraws:
			balance -= amount

		//直接更新余额
		case balances <- balance:
		}

	}
}

func init() {
	go teller()
}

```



## 通道流水线作业

第一道流水线 baker, 第二道流水线 icer

```go
package cake

type Cake struct {
	state string
}

func baker(cooked chan<- *Cake)  {
	for{
		cake := new(Cake)
		cake.state = "cooked"
		cooked <- cake //baker 不再访问cake变量
	}
}

func icer(iced chan<- *Cake, cooked <-chan *Cake)  {
	for cake := range cooked{
		cake.state = "iced"
		iced <- cake  //icer不再访问cake变量
	}
}

```



## 互斥锁

用一个容量为1的通道来保证同一时间最多有一个goroutine能访问共享变量



```go
var(
    sema = make(chan struct{}, 1)//用来保护balance的二进制信号量
    balance int
)

func Deposit(amount int){
    sema <- struct{}{} //获取令牌
    balance = balance + amount
    <- sema //释放令牌
}

func Balance() int{
    sema <- struct{}{} //获取令牌
    b := balance
    <- sema
    return b
}
```



sync包有一个单独的Mutex类型来支持互斥锁模型

```go
import "sync"

var(
	mu sync.Mutex //保护balance
    balance int
)

func Deposit(amount int){
    mu.Lock()
    balance = balance + amount
    mu.Unlock()
}

func Balance() int{
    mu.Lock()
    b := balance
    mu.Unlock()
    return b
}
```



