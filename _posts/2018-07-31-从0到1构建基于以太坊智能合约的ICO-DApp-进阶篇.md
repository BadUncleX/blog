---
layout: post
title:  " 从0到1构建基于以太坊智能合约的ICO DApp 进阶篇 "
date:   2018-07-31 14:07:12 +0800
categories: 以太坊 100days
typora-copy-images-to: ../assets/images/2018-07
typora-root-url: ../../blog_alexcode
---
<h2>Table of contents</h2>
* TOC
{:toc}



从0到1构建基于以太坊智能合约的 ICO DApp 进阶篇 笔记



> from 从0到 1构建基于以太坊智能合约的 ICO DApp







![](/assets/images/2018-07/2018-07-31-015531.jpg)

## 环境准备

```bash
mkdir ethereum-contract-workflow
cd ethereum-contract-workflow
```



```bash
npm init -y
git init
```



```bash
mkdir contracts
mkdir scripts
mkdir compiled
mkdir tests

```



```bash
yarn add solc

```



```bash
yarn add fs-extra
```



compile.js

```js
const fs = require('fs-extra');
const path = require('path');
const solc = require('solc');

//cleanup
const compiledDir = path.resolve(__dirname, '../compiled');
fs.removeSync(compiledDir);
fs.ensureDirSync(compiledDir);

//compile
const contractPath = path.resolve(__dirname, '../contracts', 'Car.sol');
const contractSource = fs.readFileSync(contractPath, 'utf8');

const result = solc.compile(contractSource, 1);
console.log(result);

// check errors
if (Array.isArray(result.errors) && result.errors.length) {
    throw new Error(result.errors[0]);
}

// save to disk
Object.keys(result.contracts).forEach(name => {
    const contractName = name.replace(/^:/, '');
    const filePath = path.resolve(compiledDir, `${contractName}.json`);
    fs.outputJsonSync(filePath, result.contracts[name]);
    console.log(`save compiled contract ${contractName} to ${filePath}`);
});
```



## 智能合约部署脚本



> The web3.js library is a collection of modules which contain specific functionality for the ethereum ecosystem.



web3是怎么连接前端和以太坊网络的？



以太坊的主网、测试网络、本地私有网络其实非常多，以太坊的钱包应用也非常多，web3.js 没有选择兼容所有的情况，而是自己制定了一个接口规范，让社区开发者为之贡献插件，插件在 web3.js 的体系里面叫做 provider



![](/assets/images/2018-07/2018-07-31-023520.jpg)



到这里https://infura.io/ 注册以太坊测试网络访问接口



introduction for infura

ENDPOINTS

Endpoints are the URLs you will use to send Ethereum and IPFS requests from your applications.



 API KEYS

Your projects will now have an API key and secret for sending requests. Using HTTPS/TLS basic auth you can sign requests with your API secret. Keep your "API secret" a secret! Your secret should never be human readable in your application.





yarn安装package之前可以先查下最新的package版本

```bash
yarn info package_name
```





安装依赖

web3.js

web3.js 的 1.x 版本尚未发布，但是相比 0.x 版本变化非常大，1.x 中大量使用了 Promise，可以结合 async/await 使用，而 0.x 版本只支持回调，因为使用 async/await 能让代码可读性更好，我们会选择使用 1.x 版本

```bash
yarn add web3@1.0.0-beta.34
```

能够兼容选择的钱包，并且和 Infura 节点通讯的 web3.js 插件，使用 [truffle-hdwallet-provider](https://www.npmjs.com/package/truffle-hdwallet-provider) 来作为 provider

```bash
yarn add truffle-hdwallet-provider@0.0.3

yarn add ethereumjs-wallet@0.6.0
```



编写部署脚本 deploy.js

```js
const path = require('path');
const Web3 = require('web3');
const HDWalletProvider = require('truffle-hdwallet-provider');

// 1. 拿到 bytecode
const contractPath = path.resolve(__dirname, '../compiled/Car.json');
const { interface, bytecode } = require(contractPath);

// 2. 配置 provider
const provider = new HDWalletProvider(
    'witness improve busy opinion addict sun gossip hedgehog common glass dignity primary',
    'https://rinkeby.infura.io/CqCd0QgCozHBEk19ub2M'
);

// 3. 初始化 web3 实例
const web3 = new Web3(provider);

(async () => {
    // 4. 获取钱包里面的账户
    const accounts = await web3.eth.getAccounts();
    console.log('部署合约的账户：', accounts[0]);

    // 5. 创建合约实例并且部署    
    console.time('contract-deploy');
    const result = await new web3.eth.Contract(JSON.parse(interface))
        .deploy({ data: bytecode, arguments: ['AUDI'] })
        .send({ from: accounts[0], gas: '1000000' });
        
    console.timeEnd('contract-deploy');    

    console.log('合约部署成功：', result.options.address);
})();
```





执行部署脚本：

```bash
node scripts/deploy.js
```



如果发现报错：

Cannot find module 'ethereumjs-wallet/hdkey'



一般是因为安装的package没有指定版本， 可以删掉node_modules然后重新安装即可， yarn方式比较友好。



正确运行结果：

```bash
➜  ethereum-contract-workflow git:(master) ✗ node scripts/deploy.js
部署合约的账户： 0xf7C2fF0740014C8776B2145Bd837494143A36E30
contract-deploy: 51290.857ms
合约部署成功： 0x00f06421A501A63EC63273f4a28Fe9fac6756EA0
```





通过metamask打开账户地址， 可以看到创建成功的合约：



![](/assets/images/2018-07/2018-07-31-050539.jpg)





## 用remix与已经部署的合约交互



在Remix新建一个文件， 将最新Car合约源代码放到编辑区域



将合约地址粘贴过去，然后就可以点击调用函数测试了：

![](/assets/images/2018-07/2018-07-31-051321.jpg)





在setBrand这里输入 “BMW”， 带引号， 然后点击setBrand按钮， metamask会弹出交易窗口

成功后再点击brand：

![](/assets/images/2018-07/2018-07-31-051322.jpg)







## 使用mocha + web3.js + ganache 编写合约测试

mocha测试依赖安装

```shell
yarn add ganache-cli mocha -D
```



测试代码tests/car.spec.js

```js
const path = require('path');
const assert = require('assert');
const ganache = require('ganache-cli');
const Web3 = require('web3');

// 1. 拿到 bytecode
const contractPath = path.resolve(__dirname, '../compiled/Car.json');
const { interface, bytecode } = require(contractPath);

// 2. 配置 provider
const web3 = new Web3(ganache.provider());

let accounts;
let contract;
const initialBrand = 'AUDI';

describe('contract', () => {
    // 3. 每次跑单测时需要部署全新的合约实例，起到隔离的作用
    beforeEach(async () => {
        accounts = await web3.eth.getAccounts();
        console.log('合约部署账户：', accounts[0]);

        contract = await new web3.eth.Contract(JSON.parse(interface))
            .deploy({ data: bytecode, arguments: [initialBrand] })
            .send({ from: accounts[0], gas: '1000000' });
        console.log('合约部署成功：', contract.options.address);
    });

    // 4. 编写单元测试
    it('deploy a contract', () => {
        assert.ok(contract.options.address);
    });

    it('has initial brand', async () => {
        const brand = await contract.methods.brand().call();
        assert.equal(brand, initialBrand);
    });

    it('can change the brand', async () => {
        const newBrand = 'BWM';
        await contract.methods.setBrand(newBrand).send({ from: accounts[0] });
        const brand = await contract.methods.brand().call();
        assert.equal(brand, newBrand);
    });
});
```



测试代码说明：

contract.methods.brand().call()，调用合约上的方法，通常是取数据，立即返回； contract.methods.setBrand('xxx').send()，对合约发起交易，通常是修改数据，返回的是交易 Hash



```shell
mocha tests
```



报错， 找不到mocha-cli module



去掉-D参数

```shell
yarn add ganache-cli mocha 
```





![](/assets/images/2018-07/2018-07-31-060418.jpg)

