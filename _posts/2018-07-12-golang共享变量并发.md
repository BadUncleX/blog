---
layout: post
title:  " golang 并发编程概述 "
date:   2018-07-12 09:15:31 +0800
categories: golang 100days
typora-copy-images-to: ../assets/images/2018-07
typora-root-url: ../../blog_alexcode
---
<h2>Table of contents</h2>
* TOC
{:toc}


今天看的是<go程序设计语言>, 把并发部分在概念上再捋一遍. 



go并发编程在风格上有两种:

1 goroutine 和 channel

2 共享内存



goroutine是Go程序并发的执行体, 通道就是它们之间的连接.  



无缓冲通道. 

不带参数的chan构造的是无缓冲通道, 意味着通道上的操作将会阻塞.  即一个发送操作后必须等待另一个接受操作完成才算完成. 



单向通道. 

因为通道既可以往里送也可以从里面取, 所以在概念上是容易混淆的, 区别的方式就是在参数上接上方向. chan<- int 是一个只能发送的通道, 允许发送但不允许接受, 反之亦然. 



缓冲通道. 

一个缓冲通道的例子, 并发地像三个镜像地址发出请求, 返回最快的那个响应. 

```go
func mirroredQuery() string{
    responses := make(chan string, 3)
    go func(){responses <- request("asia.gopl.io")}
	go func(){responses <- request("euorope.gopl.io")}
    go func(){responses <- request("americas.gopl.io")}
    return <-responses //return the quickest response
}
```

> 返回最快的服务比在clojure的那个方式简洁多了



竞态.

如果我们无法确信地说一个事件肯定先于另一个事件, 那么这两个事件就是并发的.  考虑一个函数在并发调用时仍然能够正确工作, 那么这个函数是并发安全的. 



在程序中发现竞态的方式是加入 -race参数. 



明天继续. 