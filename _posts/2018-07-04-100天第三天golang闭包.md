---
layout: post
title:  " 100天第三天 golang闭包 "
date:   2018-07-04 08:51:31 +0800
categories: golang 100days
typora-copy-images-to: ../assets/images/2018-07
typora-root-url: ../../blog_alexcode
---
<h2>Table of contents</h2>
* TOC
{:toc}


## 0

很早就听说过函数式编程的闭包, 很多人看这个也觉得不太容易懂, 之前在看clojure的时候也翻了不少资料, 记了一堆资料, 不过似懂非懂, 这一次看了点资料后, 反复从本质来思考, 发现想通了, 其实很简单. 



## 1 什么是闭包

闭包是由函数及其相关引用环境组合而成的实体 , 即:

闭包 = 函数 + 引用环境



## 2 高阶函数

在正式说闭包之前还是了解下高阶函数. 



高阶函数基本是函数式编程里都会有的, 或者是必需. 

什么是高阶函数呢? 简单说就是关于函数的函数. 

在面向对象变成世界里, 我们就是把对象传来传去; 在函数式编程世界里我们就是把函数传来传去. 函数可以看做一个普通的value, 既然是value就既可以传进去也可以传出来. 



所以, 高阶函数至少满足以下一个条件:

- 接受一个函数或多个函数作为输入
- 输出一个函数





## 3 闭包产生原因

函数可以嵌套函数, 即在一个函数内部定义另一个函数, 有了嵌套函数这种结构, 就有了闭包问题. 



闭包只是在形式和表现上像函数，但实际上不是函数。函数是一些可执行的代码，这些代码在函数被定义后就**确定**了，不会在执行时发生变化，所以**一个函数只有一个实例**。

闭包在运行时可以**有多个实例**，不同的引用环境和相同的函数组合可以产生不同的实例。所谓引用环境是指在程序执行中的某个点所有处于活跃状态的约束所组成的集合。



## 4 show me code!

先看普通函数:

```go
func adder(x int) int {
   sum := 0
   return sum + x
}


func main() {
   for i := 0; i < 10; i++ {
      fmt.Println(adder(i), adder(-2*i))
   }
}
```

输出结果:

0 0
1 -2
2 -4
3 -6
4 -8
5 -10
6 -12
7 -14
8 -16
9 -18

> 可以看到, adder函数返回的结果是确定的, 每一次调用sum都是从0开始. 



再看闭包方式:

```go
func adder() func(int) int {
   sum := 0
   return func(x int) int {
      sum += x
      return sum
   }
}


func main() {
   pos, neg := adder(), adder()
   for i := 0; i < 10; i++ {
      fmt.Println(
         pos(i),
         neg(-2*i),
      )
   }
}
```

输出结果:

0 0
1 -2
3 -6
6 -12
10 -20
15 -30
21 -42
28 -56
36 -72
45 -90

> adder函数分配给了两个变量pos, neg, 这里就是上面说的两个环境, 后面的循环执行语句, pos每次都是在前一次pos的sum值结果之上执行的, neg也是. 



## 5 闭包本质

闭包本质就是多个"局部全局变量".   语法不通, 但是意思好懂.   即, 保留状态的局部变量. 